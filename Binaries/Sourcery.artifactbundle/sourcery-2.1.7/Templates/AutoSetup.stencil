// Template name: Annotations
// Template version: 1.0

{% macro generateInitializer initializer resolver %}
    {% if initializer.parameters.count > 0 %}
        {{ type.name }}(
            {% for parameter in initializer.parameters %}
            {{ parameter.name }}: {{ resolver }}{% ifnot forloop.last %}, {% endif %}
            {% endfor %}
        )
        {% else %}
        {{ type.name }}()
    {% endif %}
{% endmacro %}

{% macro emptyFactory type %}
    static func create() -> {{ type.name }} {
        {{ type.name }}()
    }
{% endmacro %}

{% macro numberPrefix count index -%}
    {%- if count > 1 -%}{{ index }}{%- endif -%}
{%- endmacro %}

import SwiftDependencyContainer

/*
    Examples:
    /// @Factory
*/
{% for type in types.classes %}
  {% for comment in type.documentation %}
    {% if comment|contains:"@Factory" %}
extension {{ type.name }} {
    {% if type.allMethods|initializer|count > 1 %}
    // ⚠️ Warning: Generating factory methods for more than one constructor isn't supported at the moment
        {% break %}
    {% endif %}
    
    {% if type.allMethods|initializer|count == 0 %}
        {% call emptyFactory type %}
}
        {% break %}
    {% endif %}
    
    {% for initializer in type.allMethods|initializer %}
        {% if initializer.parameters.count == 0 %}
            {% call emptyFactory type %}
            {% break %}
        {% endif %}
    
    // TODO: find a more effetive solution
    static func create(
        {% if not types.based.AutoSetup|count == 1 %}_ container: DependencyContainer,{% endif%}
        {% for parameter in initializer.parameters %}
            {{ parameter.name }}: {{ parameter.typeName }} 
            {%- for resolvableType in types.all %}
                {%- for resolvableAnnotation in resolvableType.documentation where resolvableAnnotation|contains:"Singleton" %}
                    {%- if types.based.AutoSetup|count == 1 and parameter.asSource|contains:resolvableType.name %} = {{ types.based.AutoSetup.first.name }}.resolve(){% endif -%}
                {% endfor -%}
            {% endfor -%}
            {{ ", " if not forloop.last }}
        {% endfor %}
        ) -> {{ type.name }} {
        {{ type.name }}({%- for parameter in initializer.parameters %}{{ parameter.name}}: {{ parameter.name}}{{ ", " if not forloop.last }}{% endfor -%})
    }
        {% break %}
    {% endfor %}
}
    {% endif %}
  {% endfor %}
{% endfor %}

{% macro isEager annotation -%}
    {%- if annotation|contains:"Eager" -%}true{%- else -%}false{%- endif -%}
{%- endmacro %}

{% macro parseTypes annotation -%}
    {{ annotation|replace:"@Singleton(types: [",""|replace:"@EagerSingleton(types: [",""|replace:",",".self,"|replace:"])",".self" }}
{%- endmacro %}

{% macro generateDependecyResolver type needsPrefix parent %}
    static func resolve{%- if needsPrefix -%}{{ type }}{%- endif -%}() -> {{ type }} {
        {{ parent }}.resolve()
    }
{% endmacro %}

/*
    Examples:
    /// @EagerSingleton(types: [MyAbstraction])
    /// @Singleton(types: [MyAbstraction])
    /// @EagerSingleton
    /// @Singleton
*/
{% for type in types.all %}
  {% for comment in type.documentation %}
    {% if comment|contains:"@Singleton" or comment|contains:"@EagerSingleton" %}
extension {{ type.name }} {
    {% for initializer in type.allMethods|initializer %}
    static func register(in container: DependencyContainer, isEager: Bool = {% call isEager comment %}) throws {
        {% if comment|contains:"(types:" %}
        try container.register([{% call parseTypes comment %}], isEager: isEager) {
        {% call generateInitializer initializer "try $0.resolve()" %}
        }
        {% else %}
        try container.register(isEager: isEager) {
        {% call generateInitializer initializer "try $0.resolve()" %}
        }
        {% endif %}
    }
        {% break %}
    {% endfor %}
    
    {% if type.allMethods|initializer|count == 0 %}
    static func register(in container: DependencyContainer, isEager: Bool = {% call isEager comment %}) throws {
        {% if comment|contains:"(types:" %}
        try container.register([{% call parseTypes comment %}], isEager: isEager) {
    {% call generateInitializer initializer "try $0.resolve()" %}
        }
        {% else %}
        try container.register(isEager: isEager) { {{ type.name }}() }
        {% endif %}
    }
    {% endif %}
    
    {% if types.based.AutoSetup|count == 1 %}
        {% if comment|contains:"(types:" %}
            {% for innerType in comment|replace:"@Singleton(types: [",""|replace:"@EagerSingleton(types: [",""|replace:"])",""|split: ", " %}
                {% call generateDependecyResolver innerType true types.based.AutoSetup.first.name %}
            {% endfor %}
        {% else %}
            {% call generateDependecyResolver type.name false types.based.AutoSetup.first.name %}
        {% endif %}
    {% endif %}
}

    {% endif %}
  {% endfor %}
{% endfor %}

/*
    AutoSetup
*/
{% macro generateDependecyVariable type parent %}
    static var {{ type|lowerFirstLetter }}: {{ type }} { resolve() }
{%- endmacro %}

{% macro generateDependecyVariableFromTypes annotation parent %}
    {% for type in comment|replace:"@Singleton(types: [",""|replace:"@EagerSingleton(types: [",""|replace:"])",""|replace:".self",""|split: ", " %}
        {% call generateDependecyVariable type root.name %}
    {% endfor %}
{%- endmacro %}

{% for root in types.based.AutoSetup %}
extension {{ root.name}} {
    private static let shared = {{ root.name }}() // TODO: check for empty constructor
    
    static func setup() {
    {% if types.based.AutoSetup|count > 1 %}
    fatalError("There can only be one instance implementing 'AutoSetup'!")
    {% endif %}
        let container = shared.container
    {% for type in types.all %}
        {% for comment in type.documentation %}
            {% if comment|contains:"@Singleton" or comment|contains:"@EagerSingleton" %}
        try! {{ type.name }}.register(in: container)
            {% endif %}
        {% endfor %}
    {% endfor %}
    
        try! shared.override(container)
 
        try! container.bootstrap()
    }
    
    {% for type in types.all %}
        {% for comment in type.documentation %}
            {% if comment|contains:"@Singleton(types:" or comment|contains:"@EagerSingleton(types:" %}
                {% call generateDependecyVariableFromTypes comment root.name %}
            {% else %}
                {% if comment|contains:"@Singleton" or comment|contains:"@EagerSingleton" %}
                    {% call generateDependecyVariable type.name root.name %}
                {% endif %}
            {% endif %}
        {% endfor %}
    {% endfor %}
    
    static func resolve<T>() -> T {
        try! shared.container.resolve()
    }
}
    {% break %}
{% endfor %}
